<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>MISTRAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">MISTRAL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="mistral.png" alt="mistral.png"/>
</div>
<h2><a class="anchor" id="intro_sec"></a>
Introduction</h2>
<p>Mistral is an <a href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">SMT solver </a> which decides satisfiability of formulas in the <a href="http://en.wikipedia.org/wiki/Presburger_arithmetic">theory of linear arithmetic over integers </a> and theory of equality with uninterpreted functions. Mistral is written in C++ and can be used both through a graphical user interface as well as a C++ library. In addition to deciding satisfiability, Mistral consists of the following modules:</p>
<ul>
<li><a class="el" href="explain.html">Explain</a> which can be used for performing <a href="http://en.wikipedia.org/wiki/Abductive_reasoning">abductive inference </a></li>
<li><a class="el" href="simplify.html">Simplify</a> which can be used for simplifying formulas</li>
<li><a class="el" href="cooper.html">Cooper</a> which performs quantifier elimination</li>
<li><a class="el" href="msa.html">MSAFinder</a> which can be used to compute minimum satisfying assignments</li>
</ul>
<h2><a class="anchor" id="req_section"></a>
Requirements and Installation</h2>
<p>You can obtain the source code of Mistral from <a href="http://www.cs.wm.edu/~tdillig/mistral-1.1.tar.gz">http://www.cs.wm.edu/~tdillig/mistral-1.1.tar.gz</a></p>
<p>Mistral has been tested to compile on Ubuntu 12.04. First, to compile Mistral, you need to have cmake installed on your system as well as a set of other required libraries. On a recent Ubuntu/Kubuntu system, the following command will install everything you need: </p>
<div class="fragment"><pre class="fragment">
sudo apt-get install libc6-dev-i386 gettext gawk flex libmpfr-dev cmake  \
kdelibs5-dev libgtkmm-2.4-dev libboost-thread-dev libboost-serialization-dev \
libglademm-2.4-dev graphviz doxygen g++ libgmp-dev build-essential flex bison  \
binutils-gold
</pre></div><p>Once you have cmake installed, go to the mistral folder and type the following commands </p>
<div class="fragment"><pre class="fragment">
mkdir build
cd build
cmake ..
make
</pre></div><p>Once you type these commands, you can use Mistral either through a graphical user interface or as a library. For using Mistral from the GUI, type the following commands:</p>
<div class="fragment"><pre class="fragment">
cd ui
../build/ui/mistral_ui
</pre></div><p>You can only start the Mistral GUI from the /mistral/ui folder</p>
<p>If you want to use Mistral as a library, see the Section <a class="el" href="index.html#start">Getting Started</a>.</p>
<h2><a class="anchor" id="start"></a>
Getting Started</h2>
<p>Logical formulas are represented in Mistral using the <a class="el" href="classConstraint.html">Constraint</a> type. For example, you can construct boolean constants true and false in the following way: </p>
<div class="fragment"><pre class="fragment">
Constraint t(true);
Constraint f(false);
</pre></div><p> Here "t" represents the boolean constant "true" and "f" represents the boolean constant false. More complicated formulas are constructed using <a class="el" href="classTerm.html">Term</a>. Terms can be <a class="el" href="classConstantTerm.html">ConstantTerm</a> (such as 0), <a class="el" href="classVariableTerm.html">VariableTerm</a> (such as x), <a class="el" href="classArithmeticTerm.html">ArithmeticTerm</a> (such as 3x + 2y), or <a class="el" href="classFunctionTerm.html">FunctionTerm</a> (such as f(g(x, 0), a)). Here is an example illustrating creation of various kinds of terms. </p>
<div class="fragment"><pre class="fragment">
   Term* t1 = VariableTerm::make("a");
   Term* t2 = VariableTerm::make("b");

   map&lt;Term*, long int&gt; elems;
   elems[t1] = 3;
   elems[t2] = 7;
   Term* t3 = ArithmeticTerm::make(elems, 2);

   vector&lt;Term*&gt; args;
   args.push_back(t1);
   Term* t4 = FunctionTerm::make("f", args);

</pre></div><p> Here, term t3 represents the arithmetic term 3a + 7b + 2, and term t4 represents the function term f(a).</p>
<p>Now, using these terms, we can create more interesting constraints. For example, the following code snippet shows how to create the constraint f(a) &lt;= b &amp; 3a + 7b + 2 = 4:</p>
<div class="fragment"><pre class="fragment">
Constraint c1(t4, t2, ATOM_LEQ);
Constraint c2(t3, ConstantTerm::make(4), ATOM_EQ);
Constraint c3 = c1 &amp; c2;
</pre></div><p>In this example, c1 corresponds to the formula f(a) &lt;= b, c2 represents the formula 3a + 7b + 2 =4, and c3 represents the conjunction of c1 and c2. Mistral overloads the C++ operators &amp;, |, ! for performing conjunction, disjunction, and negation of formulas respectively. For example, in the following code snippet:</p>
<div class="fragment"><pre class="fragment">
Constraint c4 = !c1;
Constraint c5 = c4 | c2;
</pre></div><p>c4 represents the formula f(a) &gt; b and c5 represents the disjunction of f(a) &gt; b and 3a + 7b + 2 = 4.</p>
<h2><a class="anchor" id="sat"></a>
Checking Satisfiability and Validity</h2>
<p>Now that we can construct constraints, we can use Mistral to decide their satisfiability and validity:</p>
<div class="fragment"><pre class="fragment">
bool res1 = c5.sat_discard();
bool res2 = c3.valid_discard();
bool res3 = c5.equivalent(c3);
</pre></div><p>Here res1 is true if and only if the formula represented by c5 is satisfiable, and res2 is true if and only if the formula represented by c3 is valid. The equivalent method of <a class="el" href="classConstraint.html">Constraint</a> is used to check equivalence. Therefore, res3 is true if and only if c2 and c5 are equivalent.</p>
<p>There is also another way to check satisfiability and validity in Mistral using the sat() and valid() methods rather than sat_discard() and valid_discard(). The difference between these is that sat() and valid() also simplify the formula, as described in this <a href="http://www.cs.wm.edu/~idillig/sas2010.pdf">publication </a>. Therefore, the methods sat and valid are more expensive than sat_discard and valid_discard and should only be used if you want the formula to get simplified after performing a satisfiability or validity query. The section <a class="el" href="simplify.html">Simplify</a> describes this in more detail.</p>
<p>Given a satisfiable constraint, Mistral also provides a way for obtaining satisfying assignments as follows:</p>
<div class="fragment"><pre class="fragment">
map&lt;Term*, SatValue&gt; assignment;
bool res = c5.get_assignment(assignment);
for(auto it = assignment.begin(); it!= assignment.end(); it++)
{
    Term* t = it-&gt;first;
    SatValue sv = it-&gt;second;
    cout &lt;&lt; " Term: " &lt;&lt; t-&gt;to_string() &lt;&lt; " satisfying assignment: " &lt;&lt; sv.to_string() &lt;&lt; endl;
}
</pre></div><p>The code snippet above shows how to obtain and print the satisfying assignment for formula represented by c5. In this code snippet, res indicates whether c5 is satisfiable, and, if res is true, "assignment" is a full satisfying assignment from each term in the formula to a satisfying value.</p>
<h2><a class="anchor" id="further"></a>
Other Functionalities</h2>
<p>In addition to checking satisfiability and validity, Mistral can be used for performing abductive inference, simplifying constraints, performing quantifier elimination, and computing minimum satisfying assignments. For tutorials on using these functionalities, please refer to the <a class="el" href="explain.html">Explain</a>, <a class="el" href="simplify.html">Simplify</a>, <a class="el" href="cooper.html">Cooper</a>, and <a class="el" href="msa.html">MSAFinder</a> pages.</p>
<h2><a class="anchor" id="people"></a>
People</h2>
<p>Mistral is developed and maintained by:</p>
<ul>
<li><a href="http://www.cs.wm.edu/~tdillig/">Thomas Dillig </a></li>
<li><a href="http://www.cs.wm.edu/~idillig/">Isil Dillig </a></li>
</ul>
<p>Other people who have contributed to some of the ideas implemented in Mistral include:</p>
<ul>
<li><a href="http://www.kenmcmil.com/">Ken McMillan </a></li>
<li><a href="http://theory.stanford.edu/~aiken/">Alex Aiken </a></li>
</ul>
<h2><a class="anchor" id="publications"></a>
Publications</h2>
<p>The techniques described in the following publications are incorporated in Mistral:</p>
<ul>
<li><a href="http://www.cs.wm.edu/~idillig/cav2009.pdf">Cuts-from-Proofs: A Complete and Practical Technique for Solving Linear Inequalities over Integers </a>, Isil Dillig, Thomas Dillig, and Alex Aiken, CAV 2009</li>
<li><a href="http://www.cs.wm.edu/~idillig/sas2010.pdf">Small Formulas for Large Programs: Constraint Simplification for Scalable Static Analysis </a>, Isil Dillig, Thomas Dillig, Alex Aiken, SAS 2010</li>
<li><a href="http://www.cs.wm.edu/~idillig/cav2012.pdf">Minimum Satisfying Assignments for SMT </a>, Isil Dillig, Thomas Dillig, Ken McMillan, Alex Aiken, CAV 2012 </li>
</ul>
<h2><a class="anchor" id="ack"></a>
Acknowledgments</h2>
<p>We are grateful to the developers of the <a href="http://minisat.se/">MiniSAT </a> SAT solver, which forms the SAT solving engine of Mistral. We also thank the developers of the <a href="http://gmplib.org/">GNU MP Bignum Library </a>. </p>
<h2><a class="anchor" id="license"></a>
License and Support</h2>
<p>Mistral is freely available for research purposes under the <a href="http://www.gnu.org/licenses/gpl.html">GPL license </a>. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 13 2012 19:05:00 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
