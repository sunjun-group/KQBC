<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>MSAFinder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classMSAFinder.html">MSAFinder</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="msa.png" alt="msa.png"/>
</div>
<h2><a class="anchor" id="msa-intro"></a>
What is MSAFinder?</h2>
<p><a class="el" href="classMSAFinder.html">MSAFinder</a> is the component of Mistral that can be used to compute minimum satisfying assignments (MSA) of Presburger arithmetic formulas. An MSA of a formula F is a partial satisfying assignment of F that contains as few variables as possible, but is still sufficient to imply the validity of the formula. A precise definition of MSAs as well as the algorithm <a class="el" href="classMSAFinder.html">MSAFinder</a> uses to compute MSAs is described <a href="http://www.cs.wm.edu/~idillig/cav2012.pdf">in this paper</a>.</p>
<h2><a class="anchor" id="use-msa"></a>
Using MSAFinder</h2>
<p>To compute minimum satisfying assignments of Presburger arithmetic formulas, use the msa method provided in <a class="el" href="Constraint_8h_source.html">Constraint.h</a>. Here is an example code snippet that illustrates how to compute MSAs:</p>
<div class="fragment"><pre class="fragment">
Term* x = VariableTerm::make("x");
Term* y = VariableTerm::make("y");
Term* z = VariableTerm::make("z");

map&lt;Term*, long int&gt; elems1;
elems1[x] = 1;
elems1[y] = 1;
Term* t1 = ArithmeticTerm::make(elems1, 0);

map&lt;Term*, ling int&gt; elems2;
elems2[x] = 1;
elems2[y] = 1;
elems2[z] = 1;
Term* t2 = ArithmeticTerm::make(elems2, 0);

Constraint c1(t1, ConstantTerm::make(0), ATOM_GT);
Constraint c2(t2, ConstantTerm::make(5), ATOM_LT);
Constraint c3 = (c1 | c2);

map&lt;Term*, SatValue&gt; min_assign;
int min_vars = c3.msa(min_assign);
for(auto it = min_assign.begin(); it!= min_assign.end(); it++) {
	Term* t = it-&gt;first;
	SatValue sv = it-&gt;second;
	cout &lt;&lt; t-&gt;to_string() &lt;&lt; ":" &lt;&lt; sv.to_string() &lt;&lt; "\t";

}
</pre></div><p>Here, c3 corresponds to the formula x+y&gt;0 | x+y+z &lt;=5. The return value, min_vars, of the msa method tells us how many variables the MSA of c3 contains, and the map min_assign gives the actual minimum satisfying assignment. The for loop in the above code snippet prints a satisfying assignment for each variable in the msa. In this particular example, the minimum satisfying assignment of c3 contains only one variable, namely z, and an MSA of c3 is z=0.</p>
<p>When computing minimum satisfying assignments, one can also assign a cost to each variable. In this case, the msa method yields a partial satisfying assignment that minimizes the sum of the costs of each variable used in the assignment. For instance, consider the cost function C such that C(x) = 1, C(y) = 1, C(z) = 5. Under this cost function, z= 0 is no longer an MSA of (x+y &gt; 0 | x+y+z &lt;=5 ) because the cost of the assignment z=0 is 5, and there exists a satisfying assignment with smaller cost, such as y= 0 and x=1. The following code snippet shows how to obtain an MSA for c3 subject to a cost function C(x) = 1, C(y) = 1, C(z) =5.</p>
<div class="fragment"><pre class="fragment">
map&lt;VariableTerm*, int&gt; costs;
costs[x] = 1;
costs[y] = 1;
costs[z] = 5;


map&lt;Term*, SatValue&gt; min_assign;
int msa_cost = c3.msa(min_assign, costs);
for(auto it = min_assign.begin(); it!= min_assign.end(); it++) {
	Term* t = it-&gt;first;
	SatValue sv = it-&gt;second;
	cout &lt;&lt; t-&gt;to_string() &lt;&lt; ":" &lt;&lt; sv.to_string() &lt;&lt; "\t";

}
</pre></div><p>For this example, msa_cost is 2 and the MSA is printed as y:0 x:1. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 13 2012 19:04:57 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
